ğŸŒŸ Day 12 of the GFG160 Challenge ğŸŒŸ

ğŸš€ Problem Solved: Max Circular Subarray Sum

ğŸ’¡ Approach Used: Kadane's Algorithm â€“ O(n) Time, O(1) Space

âœ… Steps to Solve:
1ï¸âƒ£ Compute the maximum subarray sum using Kadaneâ€™s algorithm.
2ï¸âƒ£ Calculate the total sum of the array.
3ï¸âƒ£ Find the minimum subarray sum (invert the problem using Kadaneâ€™s).
4ï¸âƒ£ The result is the maximum of the two:
Â Â Â ğŸ“Œ Case 1: Standard maximum subarray sum.
Â Â Â ğŸ“Œ Case 2: Total sum - minimum subarray sum (to consider circular wrapping).

ğŸ¯ Key Takeaway:
This method efficiently finds both standard and circular subarray sums, leveraging Kadaneâ€™s algorithm twice to optimize performance.

ğŸ’» Complexity:
Time: O(n) â€“ Single traversal.
Space: O(1) â€“ No extra space.


// C++ program to find maximum Subarray Sum in Circular
// subarray by considering all possbile subarrays

#include <iostream>
#include <vector>
using namespace std;

int circularSubarraySum(vector<int> &arr) {

    int totalSum = 0;
    int currMaxSum = 0, currMinSum = 0;
    int maxSum = arr[0], minSum = arr[0];

    for (int i = 0; i < arr.size(); i++) {

        // Kadane's to find maximum sum subarray
        currMaxSum = max(currMaxSum + arr[i], arr[i]);
        maxSum = max(maxSum, currMaxSum);

        // Kadane's to find minimum sum subarray
        currMinSum = min(currMinSum + arr[i], arr[i]);
        minSum = min(minSum, currMinSum);

        // Sum of all the elements of input array
        totalSum = totalSum + arr[i];
    }

    int normalSum = maxSum;
    int circularSum = totalSum - minSum;

    // If the minimum subarray is equal to total Sum
    // then we just need to return normalSum
    if (minSum == totalSum)
        return normalSum;

    return max(normalSum, circularSum);
}

int main() {
    vector<int> arr = {8, -8, 9, -9, 10, -11, 12};
    cout << circularSubarraySum(arr);
}
